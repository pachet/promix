{
  "author": {
    "name": "Pachet",
    "email": "pachet@burninggarden.com"
  },
  "name": "promix",
  "description": "Mix promises with callbacks for improved flow control",
  "version": "0.0.2",
  "main": "./index",
  "engines": {
    "node": "*"
  },
  "devDependencies": {
    "nodeunit": "0.7.x"
  },
  "readme": "#Promix - Mix promises with Node-style callbacks for improved flow control\n##Contents\n\n1. [Install](#install)\n2. [Introduction](#introduction)\n3. [API](#api)\n\t* [promix.when](#promixwhen-) *\n\t* [chain.and](#chainand)\n\t* [chain.then](#chainthen-) *\n\t* [chain.or](#chainor)\n\t* [chain.otherwise](#chainotherwise-) *\n\t* [chain.end](#chainend-) *\n\t* [chain.until](#chainuntil-) *\n\t* [chain.assert](#chainassert-) *\n\t* [chain.as](#chainas)\n\t* [chain [label]](#chain-label)\n\t* [chain.reject](#chainreject)\n\t* [chain.stop](#chainstop-)\n\t* [chain.start](#chainstart)\n\t* [chain.break](#chainbreak)\n\t* [chain.suppress](#chainsuppress)\n\t* [chain.unsuppress](#chainunsuppress)\n\t* [chain.bind](#chainbind)\n\t* [chain.name](#chainname)\n\t* [promix.handle](#promixhandle)\n\t* [promix.promise](#promixpromise)\n4. [Examples](#examples)\n\t* [In the browser](#in-the-browser)\n\t* [In a service](#in-a-service)\n\t* [In a route](#in-a-route)\n\t* [As a generator](#as-a-generator)\n5. [License](#license)\n6. [Notes](#notes)\n\t* [Breakpoints](#breakpoints)\n\t* [Special Thanks](#special-thanks)\n\n\\* will introduce a sequential breakpoint. See [Breakpoints](#breakpoints) below.\n\n\n\n<br />\n\n##Install\n\n`````text\nnpm install promix\n`````\n\n<br />\n##Introduction\n\nWith Promix, you can turn this:\n\n`````javascript\n\nfunction doAsyncStuff ( a, b, c, callback ) {\n\tasyncOne(a, function ( error, responseA ) {\n\t\tif ( error ) {\n\t\t\treturn callback(error);\t\n\t\t}\n\t\tasyncTwo(b, function ( error, responseB ) {\n\t\t\tif ( error ) {\n\t\t\t\treturn callback(error);\n\t\t\t}\n\t\t\tasyncThree(c, function ( error, responseC ) {\n\t\t\t\tif ( error ) {\n\t\t\t\t\treturn callback(error);\n\t\t\t\t}\n\t\t\t\t//All done!\n\t\t\t\treturn callback(null, [\n\t\t\t\t\tresponseA,\n\t\t\t\t\tresponseB,\n\t\t\t\t\tresponseC\n\t\t\t\t]);\n\t\t\t});\n\t\t});\n\t});\n}\n`````\ninto this:\n\n`````javascript\nfunction doAsyncStuff ( a, b, c, callback ) {\n\tpromix.when(asyncOne, a).and(asyncTwo, b).and(asyncThree, c).end(callback);\n}\n`````\n\nPromix is a control flow library for JavaScript that makes it easy to chain asynchronous operations together.\nIf you pass in a function that accepts a trailing callback argument, Promix will transform it into a promise and add it to the chain.\nYou can pass in your own promises, too, if that's your style. Promix lets you easily mix the two, and make it out of callback hell in one piece.\n\n<br />\n##API\n\n**NOTE:** The API examples in this section use the following functions in order to illustrate asynchronous behavior:\n\n`````javascript\nfunction asyncOne ( a, b, callback ) {\n\tsetTimeout(function ( ) {\n\t\treturn callback(null, a + b);\n\t}, 10);\n}\n\nfunction asyncTwo ( c, d, callback ) {\n\tsetTimeout(function ( ) {\n\t\treturn callback(null, c * d);\n\t}, 20);\n}\n\nfunction errorFn ( label, callback ) {\n\tsetTimeout(function ( ) {\n\t\treturn callback(new Error('This function throws errors (' + label + ')'));\n\t}, 30);\n}\n`````\n\n<br />\n###promix.when() [\\*](#breakpoints)\nAccept an optional promise or callback-accepting function, and return a new chain.\n\n\nUsage:\n> **promix.when( promise )**\n\n> **promix.when( function [, arguments ] )**\n\nPass a callback-accepting function, with whatever arguments you want to supply (Promix creates the trailing callback argument for you):\n`````javascript\nvar chain = promix.when(asyncOne, 1, 2);\n`````\n\nOr just pass in a preexisting promise:\n`````javascripts\nvar promise = promix.promise();\nvar chain = promix.when(promise);\n`````\n\n<br />\n###chain.and()\nAdd a new promise or callback-accepting function as a parallel step in the chain.\n\nUsage:\n> **chain.and( promise )**\n\n> **chain.and( function [, arguments ] )**\n\n`````javascript\nvar promise = promix.promise();\nvar chain = promix.when(asyncOne, 1, 2).and(asyncTwo, 3, 4).and(promix) //---> continue adding things as need be!\n`````\n\n<br />\n###chain.then() [\\*](#breakpoints)\nAdd a new promise or function as a sequential step in the chain. All prior steps must complete before this step is evaluated.\n\nUsage:\n> **chain.then( promise )**\n\n> **chain.then( function [, arguments ] )**\n\n\nIf you pass a function to `chain.then()` as the only argument,\nthe function will be passed an array of results from all earlier steps in the chain:\n\n`````javascript\nvar chain = promix.when(asyncOne, 1, 2).and(asyncTwo, 3, 4).then(function ( results ) {\n\tconsole.log(results);\n\n\t//[3, 12]\n});\n`````\n\nIf you supply additional arguments to `.then()`, those arguments, as well as a trailing callback created by promix, will be passed to the function instead of the results object:\n\n`````javascript\nfunction someFn ( v1, v2, callback ) {\n\tsetTimeout(function ( ) {\n\t\treturn callback(v1 + v1 + v1 + ' ' + v2 + v2 + v2);\n\t}, 50);\n}\n\npromix.when(asyncOne, 1, 2).and(asyncTwo, 3, 4).then(someFn, 'a', 'b').then(function ( results ) {\n\tconsole.log(results);\n\n\t//[3, 12, 'aaa bbb']\n});\n````` \nIn the above case, the chain continues because `someOtherFn` calls the `callback` argument supplied by promix.\n\nIf you pass a promise to `chain.then()`, the chain will wait until that promise has been resolved (or rejected) before continuing:\n\n`````javascript\nvar promise = promix.promise();\n\nsetTimeout(function ( ) {\n\tpromise.fulfill(5000);\n}, 40);\n\nvar chain = promix.when(asyncOne, 1, 2).and(asyncTwo, 3, 4).then(promise).then(function ( results ) {\n\tconsole.log(results);\n\t\n\t//[3, 12, 5000]\n});\n`````\n\nA function passed to `chain.then()` can also directly return either **1)** a promise, or, for convenience, **2)** an array with a function at index 0 (just like we've been passing to our other methods) in order to continue the promise chain.\n\nFor example:\n````javascript\nfunction someOtherfn ( results, callback ) {\n\tvar promise = promix.promise();\n\n\tsetTimeout(function ( ) {\n\t\tpromise.fulfill(results [1] - results [0]);\n\t}, 50);\n\n\treturn promise;\n}\n\npromix.when(asyncOne, 1, 2).and(asyncTwo, 3, 4).then(someFn).then(function ( results ) {\n\tconsole.log(results);\n\t\n\t//[3, 12, 9]\n});\n`````\n\n<br />\t\n###chain.or()\nAdd a new promise or callback-accepting function as a sibling of the current step.\n\nUsage:\n> **chain.or( promise )**\n\n> **chain.or( function [, arguments ] )**\n\nOnly the first sibling to complete will be added to the list of results:\n`````javascript\nvar chain = promix.when(asyncTwo, 3, 4).or(asyncTwo, 1, 2).then(function ( results ) {\n\t//asyncOne completes first (see above);\n\t//we only receive asyncOne's result:\n\tconsole.log(results [0]);\n\tconsole.log(results [1]);\n\n\t//3\n\t//undefined\n});\n`````\n\n<br />\n###chain.otherwise() [\\*](#breakpoints)\nAdd a new error handler to the chain.\n\nUsage:\n> **chain.otherwise( function )**\n\nAny errors that occur will break the chain, preventing execution of further steps, and pass to the nearest handler.\n`````javascript\nvar chain = promix.when(asyncOne, 1, 2).and(errorFn, 'foo').then(function ( results ) {\n\t//we will never reach this point, because errorFn threw an error\n}).otherwise(function ( error ) {\n\tconsole.log(error);\n\n\t//Error: This function throws errors (foo)\n});\n\n*NOTE* If you do not attach an error handler using `chain.otherwise()` or `chain.end()` (see [chain.end](#end)),\nthe error will be thrown.\nYou can disable this feature by explicitly suppressing errors for your chain (see [chain.suppress]('#suppress)).\n`````\n\n<br />\n###chain.end() [\\*](#breakpoints)\nAdd a single callback to the end of the chain. This callback also acts as an error handler.\n\nUsage:\n> **chain.end( function )**\n\nCallbacks often take the form `function ( error, result ) { }`.\n`chain.end()` allows you to pass a single function of this type into the chain;\nPromix will fork it into a `.then ( results ) { }` success handler and a `.otherwise ( error ) { }` error handler behind the scenes:\n\n`````javascript\nfunction typicalCallback ( error, result ) {\n\tif ( error ) {\n\t\tthrow error;\n\t}\n\telse {\n\t\tconsole.log(result);\n\n\t\t//[3, 12]\n\t}\n}\n\npromix.when(asyncOne, 1, 2).and(asyncTwo, 3, 4).end(typicalCallback);\n`````\n\n<br />\n###chain.until() [\\*](#breakpoints)\nRepeat the current step until its result equals the supplied value, or the supplied promise completes.\n\nUsage:\n> **chain.until( value || promise )**\n\nIf you supply a value, the step in the chain before `.until()` will be repeated until its result matches the value (or it produces an error):\n`````javascript\nvar i = 0;\n\nfunction loop ( callback ) {\n\ti ++;\n\tsetTimeout(function ( ) {\n\t\treturn callback(null, i);\n\t}, 1000);\n}\npromix.when(asyncOne, 1, 2).and(loop).until(5).then(function ( results ) {\n\tconsole.log(results);\n\t\n\t//[3, 5]\n});\n`````\n\nIf you supply a promise, the prior step will be repeated until the supplied promise is resolved (or rejected).\nThis is useful because the promise supplied to `until()` will not be enumerated on the results object:\n`````javascript\nvar promise = promix.promise();\nvar i = 0;\n\nfunction loop ( callback ) {\n\ti ++;\n\tsetTimeout(function ( ) {\n\t\treturn callback(null, i);\n\t}, 100);\n}\n\nsetTimeout(function ( ) {\n\tpromise.fulfill(true);\n}, 1001);\n\npromix.when(asyncOne, 1, 2).and(loop).until(promise).then(function ( results ) {\n\tconsole.log(results);\n\n\t//[3, 10]\n});\n`````\n\n\n<br />\n###chain.assert() [\\*](#breakpoints)\n\nUsage:\n> **chain.assert( function )**\n\nAdd an assert function to the chain.\nThis function will receive the results from any earlier steps for you to test.\nIf your assert function returns `true`, the chain will continue:\n`````javascript\npromix.when(asyncOne, 1, 2).assert(function ( results ) {\n\tconsole.log(results);\n\n\t//[3]\n\n\treturn results [0] === 3;\n}).then(asyncTwo, 3, 4).then(function ( results ) {\n\tconsole.log(results);\n\n\t//[3, 12]\n});\n`````\n\nIf your assert function returns `false`, the chain will break, and an error will be passed to the nearest error handler:\n`````javascript\nvar chain = promix.when(asyncOne, 1, 2);\n\nchain.assert(function ( results ) {\n\treturn results [0] === 4;\n});\nchain.then(function ( results ) {\n\t//we will never reach this point\n});\nchain.otherwise(function ( error ) {\n\tconsole.log(error);\n\n\t//Error: Chain failed assertion\n});\n`````\n\n<br />\n###chain.as()\nAssign a label to the current step in the chain.\n\nUsage:\n> **chain.as( label )**\n\n`````javascript\nvar chain = promix.when(foo, 1, 2).as('foo');\n`````\nIn addition to living at the current step index on the results array,\nresults from steps labelled with `.as()` will be aliased as a property on the results object passed to downstream functions:\n`````javascript\nvar chain = promise.when(foo, 1, 2).as('foo');\nchain.then(function ( results ) {\n\t//results [0] === results.foo\n\tconsole.log(results [0]);\n\tconsole.log(results.foo);\n\n\t//3\n\t//3\n});\n`````\n\nIf you call `chain.as()` after an `.assert()`, you will label that assertion.\nIf the assertion returns false, the error that Promix creates from the failed assertion will be given the label that you passed into `.as()`:\n\n`````javascript\nvar chain = promix.when(asyncOne, 1, 2).and(asyncTwo, 3, 4);\n\nchain.assert(function ( results ) {\n\treturn results [1] === 14;\n}).as('Checking to make sure asyncTwo returned 14');\n\nchain.otherwise(function ( error ) {\n\tconsole.log(error);\n\t\n\t//Error: Chain failed assertion: Checking to make sure asyncTwo returned 14\n});\n`````\n\nThe `chain.as()` method will also assign a new promise property on the chain itself representing the state of the current step. See [chain \\[label\\]] below. You can also use this property to create promises that return results from the labelled step. See [chain \\[label\\]()](#label) below.\n\n<br />\n###chain \\[label\\]\nAn alias to a promise representing the state of a specific step in the chain, as designated by `chain.as()`.\n\nWhen a step in the chain is either fulfilled or rejected, the promise stored at this \n\n<br />\n###chain \\[label\\]()\n\nUsage:\n> **chain \\[label\\]( [key] )**\n\nCreate a promise to return a specific property of the chain result specified by `label`. When the specified result is ready, this promise will be fulfilled with the property at the key you specified. If no property is specified, the entire result will be returned:\n`````javascript\n\nfunction asyncArray ( callback ) {\n\tsetTimeout(function ( ) {\n\t\treturn callback(null, [ 'pikachu', 'charizard' ]);\n\t});\n}\n\nfunction asyncObject ( callback ) {\n\tsetTimeout(function ( ) {\n\t\treturn callback(null, {\n\t\t\tleaf : 'bulbasaur',\n\t\t\twater : 'vaporeon'\n\t\t});\n\t});\n}\n\nfunction additionalFn ( val1, val2, val3 ) {\n\tconsole.log(val1);\n\tconsole.log(val2);\n\tconsole.log(val3);\n}\n\nvar chain = promix.when(asyncOne, 1, 2).as('one').and(asyncArray).as('array').and(asyncObject).as('object');\nchain.then(additionalFn, chain.one(), chain.array(1), chain.object('water'));\n\n//3\n//'charizard'\n//'vaporeon'\n`````\n\n<br />\t\n###chain.reject()\n\nUsage:\n> **chain.reject( error )**\n\n> **chain.reject( label )**\n\nExplicitly rejects the current chain with the supplied error.\n\nYou can pass a string, and Promix will create an error for you:\n\n`````javascript\nvar chain = promix.when(asyncOne, 1, 2);\nchain.then(function ( results ) {\n\tchain.reject(new Error('No good reason'));\n\t//or just\n\tchain.reject('No good reason');\n}).otherwise(function ( error ) {\n\tconsole.log(error);\n\n\t//Error: No good reason\n});\n`````\n\n<br />\n###chain.stop() [\\*](#breakpoints)\nStop the execution of any future steps in the chain.\n\nThis method is useful if you want to break the chain without introducing an error:\n`````javascript\nvar chain = promix.when(asyncOne, 1, 2);\n\nchain.then(function ( results ) {\n\tconsole.log(results);\n\t\n\t//[3]\n\t\n\tchain.stop();\n});\n\nchain.then(function ( results ) {\n\t//we will not reach this point\n});\n`````\n\nNote that after calling `chain.stop()`, you can still restart the chain at a later time (see [chain.start](#start)).\nIf you want to **permanently** halt execution of the chain, ensuring no future steps are executed, use [chain.break](#break).\n\n<br />\n###chain.start()\nRestart a chain that has been stopped. If `chain.stop()` has not been called, this method has no effect.\n\nThis method is useful for controlling when sequential steps are executed:\n`````javascript\nvar chain = promix.when(asyncOne, 1, 2).stop();\nchain.and(asyncTwo, 3, 4).then(function ( results ) {\n\tconsole.log(results);\n\n\t//[3, 12]\n});\n\n//the chain will be resumed after 2 seconds:\nsetTimeout(chain.start, 2000);\n`````\n\n<br />\n###chain.break()\nPermanently break the chain, preventing the execution of any subsequent steps.\n\n`````javascript\nvar chain = promix.when(asyncOne, 1, 2);\n\nchain.then(function ( results ) {\n\tchain.break();\n});\n\nchain.then(function ( results ) {\n\t//we will never reach this point\n});\n`````\n\n<br />\n###chain.suppress()\nPrevent the default behavior of errors that occur within the chain.\n\nUsage:\n> **chain.suppress( [number || label] )**\n\nIf an error occurs at a step in the chain, this method will prevent that error from being passed to the associated error handler.\n\nCalling `chain.suppress()` with no argument will suppress the behavior of all errors on the chain:\n\n`````javascript\nvar chain = promise.when(asyncOne, 1, 2).suppress();\n\nchain.reject(new Error('This error will be suppressed'));\n\n//no error thrown\n`````\n\nYou can specify an optional number of future errors to suppress. Additional errors after that number will be treated as normal.\n`````javascript\nvar chain = promise.when(errorFn, 'foo').as('almostError');\nchain.and(asyncOne, 1, 2);\nchain.suppress(1).then(function ( results ) {\n\t//the error from errorFn was suppressed, so we make it here\n\tconsole.log(results);\n\tconsole.log(results.almostError);\n\n\t//[3]\n\t//null\n}).then(errorFn, 'bar');\nchain.otherwise(function ( error ) {\n\t//the second error was not suppressed, so the error handler is called\n\tconsole.log(error);\n\t\n\t//Error: This function throws errors (bar)\n});\n`````\n\nYou can also suppress errors that originate within a specific step of the chain by passing in the string identifier for that step (see [chain.as](#as)):\n`````javascript\nvar chain = promix.when(asyncOne, 1, 2).and(errorFn, 'foo').as('errorFn');\nchain.suppress('errorFn').then(function ( results ) {\n\tconsole.log(results);\n\t\n\t//[3]\n});\n`````\n\n<br />\n###chain.unsuppress()\nReenable the normal treatment of errors introduced within the chain.\n\nUsage:\n> **chain.unsuppress( [label] )**\n\nCalling `chain.unsuppress()` with no arguments will cause future errors introduced on the chain to be treated as normal:\n`````javascript\nvar chain = promix.when(asyncOne, 1, 2).and(errorFn, 'foo').suppress();\nchain.then(asyncTwo, 3, 4).and(errorFn, 'bar').unsuppress();\nchain.otherwise(function ( error ) {\n\tconsole.log(error);\n\n\t//Error: This function throws errors (bar)\n});\n`````\n\nYou can also specify an optional string label to `chain.unsuppress()` that reenables error treatment for a specific step in the chain as designated by the label (see [domain.as](#as)). Other suppressed steps will not be affected:\n`````javascript\nvar chain = promix.when(asyncOne, 1, 2);\nchain.and(errorFn, 'foo').as('errorOne');\nchain.and(errorFn, 'bar').as('errorTwo');\nchain.suppress();\nchain.unsuppress('errorTwo');\nchain.otherwise(function ( error ) {\n\tconsole.log(error);\n\t\n\t//Error: This function throws errors (bar)\n});\n`````\n\n<br />\n###chain.bind()\nBind the execution context of the current step in the chain.\n\nUsage:\n> **chain.bind(context)**\n\nSome functions depend on the context on which they are called. Using `chain.bind()`, we can supply this execution context for specific steps in the chain:\n`````javascript\nvar someObj = {\n\ttransform : function ( text, callback ) {\n\t\tsetTimeout(function ( ) {\n\t\t\treturn callback(null, text.split('').reverse().join(''));\n\t\t}, 50);\t\n\t},\n\tgetName : function ( text, callback ) {\n\t\tthis.transform(text, callback);\n\t}\n};\n\nwhen(someObj.getName, 'pikachu').then(function ( results ) {\n\t//we will not reach this\n}).otherwise(function ( error ) {\n\tconsole.log(Error);\n\n\t//Uncaught TypeError: Object [Object] has no method 'transform'\n});\n\n//let's try again, using chain.bind():\nwhen(someObj.getName, 'pikachu').bind(someObj).then(function ( results ) {\n\tconsole.log(results);\n\t\n\t//['uhcakip']\n}).otherwise(function ( error ) {\n\t//we will not reach this\n});\n\n`````\n\n<br />\n###chain.name()\nAssign a name to the chain. This is handy for identifying which chain threw an error, for instance.\n\nUsage:\n> **chain.name( label )**\n\n<br />\n###chain.time()\nRetrieve the amount of time that the chain has taken to complete, in milliseconds.\n\nUsage:\n> **chain.time( [label] )**\n\nIf no label is supplied to `chain.time()`, the method will return the total amount of time that the chain has spent in an active state (ie, waiting for callbacks and promises to complete):\n\n`````javascript\nfunction oneSecond ( callback ) {\n\tsetTimeout(callback, 1000);\n}\n\nfunction twoSeconds ( callback ) {\n\tsetTimeout(callback, 2000);\n}\n\nvar chain = promix.when(oneSecond).and(twoSeconds).then(function ( results ) {\n\t//notice that the requests are in parallel, and therefore overlap:\n\tconsole.log(chain.time());\n\t\t\n\t//2000\n});\n`````\n\nIf you pass a label for a step in the chain (see [chain.as](#chainas)) to `chain.time()`, the method will re\nturn the amount of time spent waiting for just that step to complete:\n`````javascript\nfunction oneSecond ( callback ) {\n\tsetTimeout(callback, 1000);\n}\n\nfunction twoSeconds ( callback ) {\n\tsetTimeout(callback, 2000);\n}\n\nvar chain = promix.when(oneSecond).as('one').and(twoSeconds).as('two');\nchain.then(function ( results ) {\n\tconsole.log(chain.time('one'));\n\tconsole.log(chain.time('two'));\n\t\t\n\t//1000\n\t//2000\n});\n`````\n\n<br />\n###promix.promise()\nCreate a new promise.\n\nUsage:\n> **promix.promise( [base object] )**\n\nThis promise is Promises/A+ compliant, meaning it exposes a `.then()` method that can be used to attach success and error handlers:\n`````javascript\nvar promise = promix.promise();\n\nfunction success ( result ) {\n\tconsole.log(result);\n\n\t//vaporeon\n}\n\nfunction failure ( error ) {\n\t//our promise wasn't rejected,\n\t//so we won't reach this\n}\n\npromise.then(success, failure);\npromise.fulfill('vaporeon');\n`````\n\nYou can pass an optional object to `.promise()`, and that object will inherit the `.then()`, `.fulfill()`, and `.reject()` methods.\n`````javascript\nvar promise = promix.promise({\n\tfoo : 'foo',\n\tbar : 'bar',\n\tbaz : 'baz'\n});\n\nconsole.log(promise);\n\n//\t{\n//\t\tfoo : 'foo',\n//\t\tbar : 'bar',\n//\t\tbaz : 'baz',\n//\t\tthen : [function then],\n//\t\tfulfill : [function fulfill],\n//\t\treject : [function reject]\n//\t}\n`````\n\n<br />\n###promix.handle()\nSet the global error handler for uncaught promise/chain errors.\n\nUsage:\n> **promix.handle( function )**\n\nIf a promise is rejected with an error and has no error handler of its own to receive it, Promix will pass that error into the global handler specified with `.handler()`, if it exists. This will keep the error from being thrown:\n\n`````javascript\nvar promise = promix.promise();\npromix.handle(function ( error ) {\n\tconsole.log(error);\n\n\t//Error: An arbitrary error\n});\n\n//only supply a success handler:\npromise.then(function ( result )  {\n\t//we will never reach this\n});\n\npromise.reject(new Error('An arbitrary error'));\n`````\n\n Any uncaught errors within chains created with `promix.when()` will pass to the global handler, as well:\n`````javascript\npromix.handle(function ( error ) {\n\tconsole.log(error);\n\n\t//Error: This function throws errors (foo)\n});\n\nvar chain = promix.when(errorFn, 'foo').then(function ( results ) {\n\t//we will never reach this\n});\n`````\n\n<br />\n##Examples\n\n<br />\n###In the browser\n\n`````javascript\nvar $wrapper = $('#wrapper');\nvar start = offset;\nvar loading = false;\nvar wrapperHeight = 0;\n\nfunction loadEntries ( category, start ) {\n\treturn $.get('/news/' + category + '/entries/?start=' + start);\n}\n\nfunction loadImageFor ( entry ) {\n\tvar promise = promix.promise();\n\tvar image = new Image();\n\timage.onload = function ( ) {\n\t\tpromise.fulfill();\n\t};\n\timage.src = '/images/' + entry.thumbnail;\n\n\treturn promise;\n}\n\nfunction addEntries ( entries ) {\n\t$wrapper.append(Handlebars.templates.entries(entries));\n\tloading = false;\n\twrapperHeight = $wrapper.height();\n}\n\n//Load the list of entries from the server,\n//wait for the first image to load, then show the list:\nfunction showNextEntries ( ) {\n\tvar chain = promix.when(loadEntries, 'javascript', offset).as('entries');\n\toffset += 10;\n\tchain.then(loadImageFor, chain.entries(0));\n\tchain.then(addEntries, chain.entries());\n\tchain.then($.fn.fadeIn).bind($wrapper).otherwise(showError);\n}\n\nshowNextEntries();\n`````\n\n<br />\n###In a service\n\n`````javascript\n//Return the 10 most recent entries:\nfunction getEntries ( category, offset, callback ) {\n\tvar query = 'SELECT uuid, title, thumbnail, author, description, body, date FROM Entries WHERE active = 1 AND category = ? ORDER BY date DESC LIMIT 10 OFFSET ?';\n\tpromix.when(sql.query, query, [category, offset]).end(callback);\n}\n`````\n\n<br />\n###In a route\n`````javascript\n//Request entries and send them back as JSON:\nrouter.get('/news/:category/entries/', function ( request, response, next ) {\n\tpromix.when(getEntries, request.params.category, request.query.offset)\n\t\t.then(response.send).as('json')\n\t\t.otherwise(next);\n});\n`````\n\n<br />\n###As a generator\n`````javascript\n//Recycling the showNextEntries function from the first example:\nvar generator = promix.chain(showNextEntries).stop().until(false);\nvar $window = $(window);\n\n$window.on('scroll', function ( event ) {\n\tif ( loading ) {\n\t\treturn;\n\t}\n\tif ( $window.scrollTop() > wrapperHeight - 200 ) {\n\t\tgenerator.start();\n\t}\n});\n`````\n\n<br />\n##License\n\nPromix is MIT licensed. You can read the license [here](https://raw.github.com/reflex/promix/master/license).\n\n<br />\n##Notes\n\n<br />\n###Breakpoints\n\nCertain Promix chain methods act as chain breakpoints. \nThese methods are designated with an asterisk (\\*) throughout this documentation.\nA breakpoint is a step in the execution of a chain that necessarily introduces sequential behavior.\n\nFor instance, in the following example:\n`````javascript\npromix.when(foo).and(bar).and(baz).then(wat);\n`````\nThe `.then(wat)` step is a breakpoint, because it requires everything before it to be completed before it will execute.\n\n\n\n",
  "readmeFilename": "README.md",
  "_id": "promix@0.0.1",
  "_from": "promix@0.x.x"
}
